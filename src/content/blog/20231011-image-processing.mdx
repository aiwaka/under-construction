---
title: 我流ブログ用画像処理について
description: 最近使っているソフトウェアや手法などを書いておきます
thumbnail:
  type: local
  filename: blue_square
  format: png
date: 2023-10-12
tags:
  - プログラミング
  - シェルスクリプト
  - 画像処理
---

export const ARTICLE_ID = "20231011-image-processing";
import BlogImagesList from "@components/blog/BlogImagesList.astro";

## はじめに

最近ブログを書いたり、[こういうもの](/under-construction/station-collections)を作ったせいで画像を大量に取り扱うようになりました。
最初はWebPもあまり好きではないとか言っていたのですが、JPEGだろうがWebPだろうが可搬性はそれほど変わらないと考えて最近は使うようになったりしています。
そんな感じで品質や加工の楽さ、容量のバランスをとった画像圧縮処理を自分なりに積み上げたので一度公開しておきます。

## 環境

M1 Macbook Airです。
メモリは8GB。
シェルはzshですがなんでもいいでしょう。
xargsとかはBSD版とGNU版の違いに注意する必要があるかも知れません。

## 利用ツール

コマンドライン前提ですがGUIソフトも使います。
このGUIソフトがMac限定です。

- ImageMagick（7.1.1-19 GCC）：古典的な画像処理コマンドラインソフトウェアです。最近は代替品があるようですがとりあえずこれを使っています。
- mozjpeg（4.1.4）：Mozillaが開発したJPEGエンコーダです。ソースコードしか配布されていないようですがHomebrewならとりあえず簡単に入れられます。知識があれば`cmake`で簡単にビルド可能です。
- ToyViewer（5.8.0）：シンプルな画像編集ソフトウェアですが、私のニーズに完璧に合うため利用しています。
  Macのみで、OSの更新のたびにバイナリはつくられていますがもはや開発されておらず、先行きは少々不安です。

## 作業内容

まず、JPEGを始めとするフォーマットに対する画像エンコーダには設定可能な項目が多くありますが、自分としてはそこを詰め切ることにあまり意義を感じない~~上に面倒な~~ため、最低限のオプションで望ましい結果が得られることを念頭に置いています。
ここはこうした方がいいとかあったらGitHubのIssueで適当に書いておいていただけると非常に助かります。

私はカメラを持っていないのでiPhoneで撮影した画像を使います。
そのため、複数並んだHEIC形式をどのように処理するかということについて書きます。
最終的なフォーマットとしてはWebPを使います。
WebPはもはやほとんど100%のブラウザで利用できるため、こちらを使います。
AVIFに関しては、SafariやEdge等少なからぬブラウザで見られない可能性があるため利用しません。
WebPのほうが優れているためJPEGをそのままは使わず、PNGは重すぎるため外部サービスにアップするのは厳しいということでこれらの社会に普及しているものも使わないこととします。
どうしても可逆にしたい場合にはWebPのロスレスモードを使います。
GIFやTIFF等は論外です。

### 行程の例

サンプルとして`IMG.HEIC`という名前の画像を使うことにします。
元の容量は`ls -kls IMG.HEIC`で調べると1928KBとのこと。

#### 1. HEIC画像をJPGに変換

ImageMagickの`mogrify`サブコマンドを使います。
`convert`では出力先ファイルを指定せねばならず、複数の画像指定ができません。

```shell
magick mogrify -format JPG -strip -quality 90 *.HEIC
```

- `-format`で指定した文字列がそのまま拡張子になるようで、別に`jpg`でも`jpeg`でもよしなに動作してくれるようです。
- `-strip`はEXIFデータを除去します。
  ブログに使うなら必須です。
- `-quality`は90を指定していますが、85以上は殆ど画質は変わらず容量だけが増えていくとのこと。
  まあ少し良いものをというおまじないです。

`mogrify`は出力ファイル名を指定できず、拡張子が変化した場合はファイル名を据え置いた別ファイルが生成され、変化しない場合は上書きしてしまうので注意です（このあたりが前時代的と言うかあまりにインターフェイスが悪いと思います）。
慎重を期すなら`xargs`を用いて`convert`に渡したほうがいいかもしれません。
この処理で生成された`IMG.JPG`の容量は2148KBでした。

#### 2. 映り込んだ個人情報を潰す

ToyViewerを使います。
ToyViewerを起動するとDeckにアイコンが出るだけで何も起こりません。
画像ファイルをFinderからDeckのアイコンにD&Dすると画像が読み込まれ、編集可能になります。
角度等の調整もできるようですが、拡大縮小すると再読み込みで固まることがあり、ぼかしと90度単位の回転でのみ利用しています。
ぼかしについて、一般的なガウスフィルタの他、Kuwaharaフィルタというあまり見慣れないものが選べます。
これが非常に良く、高精細すぎない写真に対しては陰影と面をのこしたまま塗りつぶすような処理になり、全体の雰囲気を崩さずに顔や書面を潰すことができます。
起動直後にデフォルトで範囲選択モードになっているためウィンドウ上でドラッグして範囲選択し、リボンメニューの「特殊効果」 &rarr; 「シャープ化／ぼかし」を選ぶことで使えます。
適用すると適用後の画像ウィンドウが生成されますが、特徴的なこととして適用前の画像ウィンドウがそのまま残されています。
適用結果が気に入らなかった場合、そのウィンドウをCommand+Wで消してしまうことで操作のアンドゥできます。
これは一長一短で、差分を残さないため連続したアンドゥに対して安定している他、確認も非常に簡単です。
対してメモリ使用量は増えていることでしょう。

ToyViewerの使い方について書きましたが、とにかくこれで人の顔を潰せるようになりました。
加工後は普通にCommand+Sで現在のアクティブウィンドウが画像として保存されます。
HEIC等も出力に選べるのが驚きですが、素直にJPGで保存します。

#### 3. JPGを最適化

mozjpegを使います。
Homebrewでインストールしてもパスが通らず、`brew info mozjpeg`で情報を表示すると「パスの最初に追加するなら」云々が書いてあるためこの作業が必要です。
これは標準の`libjpeg`のコマンド名である`cjpeg`と競合してしまうため、意図しない動作変更が起こらないようにするための仕様のようです（どうしてそんな名前にするのかと思いましたが`libjpeg`とインターフェイスを互換にして簡単に導入できるようにするためのような気もします）。

mozjpegは単にJPGを食わせて実行すると標準出力に結果のバイナリが吐き出されます（最初に面食らいました）。
リダイレクトでファイルに出力する必要がありますが、`-outfile`オプションで出力ファイル名を指定することもできます。
この仕様上やはり複数ファイルの同時処理はできないため、`xargs`を用いて一つずつ処理させます。
JPEG形式であれば読んでくれますが、JPEGの拡張子は先述したように`JPG`、`jpg`、`jpeg`など多岐にわたります。
そのため、拡張子だけ指定できる環境変数を作っておいてワンライナー中で使うことにします。

```shell
% export TARGET_EXT=JPG
% ls *.$TARGET_EXT | xargs -I{} basename {} .$TARGET_EXT | xargs -I{} cjpeg -optimize -quality 80 -outfile optimized_{}.jpg {}.$TARGET_EXT
```

あまり仕様を把握できておらず`basename`を変数展開の中で使うとうまく動かないので回りくどい書き方をしています。
`cjpeg`について、

- `-optimize`オプションをつけて最適化を指示します。
- `-quality`は80にしていますが85でも十分な圧縮効果です。このあたりは場合によって使い分けます。
- `-outfile`は先述した通り出力ファイル名を指定します。ここではoptimized\_をつけています。

`optimized_IMG.jpg`の容量は1064KBでした。

#### 4. WebPに変換する

ImageMagickの`mogrify`を使います。
行程1と同じようにコマンド実行します。

```shell
magick mogrify -define webp:method=6 -format webp -strip -resize 80% optimized_IMG.jpg
```

- `mogrify`は`-define`でエンコーダに特有の設定を渡すことができるみたいです。
  `webp:method=6`で最も圧縮率が高い設定にしています。
- `-resize`は名前の通りサイズを変更します。このように%指定もできる他、`1500x1200`のようなピクセルサイズ指定もできます。`1500x`にすることで幅のみを指定することも可能です。

これで生成される`optimized_IMG.webp`のサイズは172KBでした。
もとの10分の1に減っています。

### mozjpegを挟まない場合との比較

`mogrify`を用いて`IMG.HEIC`や`IMG.JPG`を直接webpにすることももちろん可能です。

```shell:HEICから
% magick mogrify -define webp:method=6 -format webp -strip -resize 80% IMG.HEIC
% ls -kls | grep IMG.webp
216 -rw-r--r--    ...
```

```shell:JPGから
% magick mogrify -define webp:method=6 -format webp -strip -resize 80% IMG.JPG
% ls -kls | grep IMG.webp
832 -rw-r--r--    ...
```

このようにmozjpegでの最適化を行わない場合は少なからぬ違いがあります。
mozjpegは符号の最適化を行うらしいですが、Magickでwebpに変換する際にその符号を再利用しているのかもしれません。

というか、mozjpegをかませるためにJPGに変換している段階で情報が落ちているだけのような気もしますが、JPGから直接webpに変換すると逆に大きくなってしまうのも難しいところです。

## おわり

というわけで最近使っている画像圧縮方法についてまとめました。
様々なアルゴリズムがあって学ぶと楽しそうですが知らないうちは混沌としすぎていて全然楽しくありません。
見た目についてはほぼ違いはわからないため正直なところなんでもいいだろうという大らかさでやっていきたいと思います。
