---
import type { InferGetStaticPropsType } from "astro";
import { getImage } from "astro:assets";

import allStationList from "@lib/other/station-collections/data/stationList";

import type {
  DownloadedStationCollection,
  StationImageTypeOptions,
} from "@lib/schema/station";
import type { LineDataSchema } from "@lib/types";
import { dateText } from "@lib/utils";
import {
  getStationEntries,
  getDownloadedStationCollectionsData,
} from "@lib/other/station-collections";

import GeneralPageLayout from "@layouts/GeneralPageLayout.astro";
import CollectionPictureList from "@components/other/station-collections/CollectionPictureList.astro";
import StationPageLink from "@components/other/station-collections/StationPageLink.svelte";

export async function getStaticPaths() {
  /** 何らかの理由で取得に失敗した瞬間`true`になる */
  let stationCollectionsFetchFailed = false;
  let stationCollectionsData: DownloadedStationCollection | null = null;
  try {
    stationCollectionsData = getDownloadedStationCollectionsData();
  } catch (e) {
    console.error(e);
    stationCollectionsFetchFailed = true;
  }

  if (stationCollectionsFetchFailed || stationCollectionsData === null) {
    return [];
  }
  const stationEntries = await getStationEntries(stationCollectionsData);
  return stationEntries.map((entry) => {
    const entryStaId = entry.id;
    // 企業ごとにこの駅の路線IDを持つ路線をリストアップする（全データの部分集合を作る）
    const linesAboutCompany: typeof allStationList = {};
    Object.keys(allStationList).forEach((companyId) => {
      Object.keys(allStationList[companyId].lines).forEach((lineId) => {
        // 駅リストの方を参照し, そちらが含んでいたらリストに入れる.
        if (
          allStationList[companyId].lines[lineId].stations.find(
            (sta) => sta.slug === entry.id,
          )
        ) {
          // 事業者データが未作成なら作成
          if (!(companyId in linesAboutCompany)) {
            const { lines: _, ...rest } = allStationList[companyId];
            linesAboutCompany[companyId] = { ...rest, lines: {} };
          }
          linesAboutCompany[companyId].lines[lineId] =
            allStationList[companyId].lines[lineId];
        }
      });
    });
    // 日本語の路線名リストを作る. 路線ごとに名前を取得し, ユニークにする.
    // 厳密にその駅を含まない路線はカッコで囲む.
    const jaLineNames = Array.from(
      new Set(
        Object.values(linesAboutCompany).flatMap((companyData) => {
          return Object.keys(companyData.lines).flatMap((lineId) => {
            let resultStr = "";
            resultStr += entry.lineIds.includes(lineId) ? "" : "(";
            resultStr += companyData.lines[lineId].lineName;
            resultStr += entry.lineIds.includes(lineId) ? "" : ")";
            return resultStr;
          });
        }),
      ),
    );
    // 路線ごとに隣の駅を算出する
    // TODO: すべて同じ企業の駅の場合は正式な路線名を使う
    interface SiblingStationType {
      lineName: string;
      prev?: LineDataSchema["stations"][number];
      next?: LineDataSchema["stations"][number];
    }
    const siblingsStations: SiblingStationType[] = [];
    // すでに処理した路線名リスト. 重複検知に使う.
    const treatedLineNames: string[] = [];
    Object.values(linesAboutCompany).forEach((companyData) => {
      Object.values(companyData.lines).forEach((lineData) => {
        const lineName = lineData.lineName;
        // インデックスベースで隣接駅を取得する.
        const index = lineData.stations.findIndex(
          (sta) => sta.slug === entry.id,
        );
        if (index === -1) throw Error("路線の検出に誤りがあります。");
        const prev = index === 0 ? undefined : lineData.stations[index - 1];
        const next =
          index === lineData.stations.length - 1
            ? undefined
            : lineData.stations[index + 1];
        if (treatedLineNames.includes(lineName)) {
          // 処理済みとされている場合はJRの重複であるため特殊処理.
          const existing = siblingsStations.find(
            (sta) => sta.lineName === lineName,
          );
          if (existing === undefined)
            throw Error("隣接駅の登録に誤りがあります。");
          // prevかnextのいずれかがundefinedのはずである（亀山とかは考えずデータ側で除外）.
          const prevIsUndef = existing.prev === undefined;
          if (prevIsUndef && prev !== undefined) {
            existing.prev = prev;
          } else if (!prevIsUndef && next !== undefined) {
            existing.next = next;
          }
        } else {
          treatedLineNames.push(lineName);
          siblingsStations.push({ lineName, prev, next });
        }
      });
    });

    return {
      params: { slug: entryStaId },
      props: { entry: entry, jaLineNames, siblingsStations },
    };
  });
}

type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { entry, jaLineNames, siblingsStations } = Astro.props as Props;
const { name, CommentContent, updatedAt, images, firstVisitDate, noDataFlag } =
  entry;

// typeが駅舎のものを探す。無ければのものを使う
const thumbImage =
  images.length === 0
    ? null
    : images.find((img) => img.type.includes("駅舎")) || images[0];
const thumbnail =
  thumbImage === null
    ? null
    : await getImage({
        src: thumbImage.src,
        height: thumbImage.height,
        width: thumbImage.width,
      });

const imageOptions = [
  "駅舎",
  "駅構内",
  "駅周辺",
  "駅名標",
  "車両",
  "時刻表",
  "路線図",
  "スタンプ",
  "切符",
] satisfies StationImageTypeOptions[];

const PAGE_NAME = `Under Construction | 鉄道駅コレクション ${name}` as const;

const ogp = {
  url: Astro.request.url,
  type: "blog",
  title: PAGE_NAME,
  description: "訪問した鉄道駅をまとめたページです",
  siteName: "Under Construction",
  image:
    "https://aiwaka.github.io" +
    (thumbnail?.src ?? "/under-construction/img/blue_2.png"),
};
---

<GeneralPageLayout ogp={ogp} title={PAGE_NAME}>
  <a
    href={`${import.meta.env.BASE_URL}station-collections`}
    class="to-top-anchor">コレクショントップへ戻る</a
  >
  {/* TODO: 駅名標っぽくしたい */}
  <h1>{name}</h1>
  <div class="station-lines-block">
    <span>所属路線：{jaLineNames.join("・")}</span>
  </div>
  <div class="date-block">
    <span>
      初訪問日：{firstVisitDate ? dateText(new Date(firstVisitDate)) : "不明"}
    </span>
  </div>
  <div class="update-date-block">
    <span>
      {dateText(new Date(updatedAt), "Asia/Tokyo")}更新
    </span>
  </div>
  {
    thumbnail !== null && (
      <div class="img-container">
        <img
          src={thumbnail.src}
          width={thumbnail.attributes.width}
          height={thumbnail.attributes.height}
          alt={thumbnail.attributes.alt}
          loading="eager"
          decoding="async"
        />
      </div>
    )
  }

  <div class="comment-container">
    <CommentContent class="comment" />
  </div>

  {
    imageOptions.map((opt) => {
      return (
        <>
          <h2>{opt}</h2>
          {noDataFlag.includes(opt) ? (
            <div style="margin: 1.5rem auto;">
              <p>この駅には該当するものがありません。</p>
            </div>
          ) : (
            <CollectionPictureList
              images={images.filter((i) => i.type.includes(opt))}
            />
          )}
        </>
      );
    })
  }

  <h2>隣の訪れた駅</h2>
  {
    siblingsStations.map((line) => {
      return (
        <>
          <h3>{line.lineName}</h3>
          <div class="siblings-container">
            {line.prev && (
              <div class="sibling-link prev">
                <div class="link-text">
                  &larr; <StationPageLink data={line.prev} />
                </div>
              </div>
            )}
            {line.next && (
              <div class="siblings-link next">
                <div class="link-text">
                  <StationPageLink data={line.next} /> &rarr;
                </div>
              </div>
            )}
          </div>
        </>
      );
    })
  }

  <a
    href={`${import.meta.env.BASE_URL}station-collections`}
    class="to-top-anchor">コレクショントップへ戻る</a
  >
</GeneralPageLayout>

<style>
  .comment-container {
    margin: 1.5rem auto;
  }
  .comment-container :global(a) {
    color: darkgoldenrod;
    &:hover {
      color: orangered;
    }
  }
  .to-top-anchor {
    color: var(--main-font-color);
    text-decoration: underline;
  }
  .img-container {
    border: 4px solid var(--main-font-color);
    width: 100%;
    height: 22rem;
    clip: rect(0, 0, 0, 0);
    margin: 1rem auto;
  }
  .img-container > img {
    object-fit: cover;
    width: 100%;
    height: 100%;
  }
  p.comment {
    margin: 1.2rem auto;
    margin-left: 0.4rem;
  }
  .siblings-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    column-gap: 25%;
    margin: 1rem 0;

    @media (max-width: 1024px) {
      column-gap: 1rem;
    }
  }
  .siblings-link {
    display: flex;
  }
  .prev {
    grid-column: 1 / 2;
  }
  .next {
    grid-column: -2 / -1;
    justify-self: flex-end;
  }
</style>
 @lib/other/station-collections/data/stationList@lib/other/station-collections
