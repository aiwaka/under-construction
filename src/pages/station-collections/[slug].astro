---
import type { InferGetStaticPropsType } from "astro";
import { getImage } from "astro:assets";

import allStationList from "@lib/other/station-collections/data/stationList";

import type {
  DownloadedStationCollection,
  StationImageTypeOptions,
} from "@lib/schema/station";
import type {
  CompanyDataSchema,
  LineDataSchema,
  SiblingStationType,
} from "@lib/types";
import { dateText } from "@lib/utils";
import {
  getStationEntries,
  getDownloadedStationCollectionsData,
} from "@lib/other/station-collections";
import { createHrefToLineSlug } from "@lib/other/station-collections";

import GeneralPageLayout from "@layouts/GeneralPageLayout.astro";
import CollectionPictureList from "@components/other/station-collections/CollectionPictureList.astro";
import SiblingStationOfLine from "@components/other/station-collections/SiblingStationOfLine.astro";

export async function getStaticPaths() {
  /** 何らかの理由で取得に失敗した瞬間`true`になる */
  let stationCollectionsFetchFailed = false;
  let stationCollectionsData: DownloadedStationCollection | null = null;
  try {
    stationCollectionsData = getDownloadedStationCollectionsData();
  } catch (e) {
    console.error(e);
    stationCollectionsFetchFailed = true;
  }

  if (stationCollectionsFetchFailed || stationCollectionsData === null) {
    return [];
  }
  const stationEntries = await getStationEntries(stationCollectionsData);
  return stationEntries.map((entry) => {
    const entryStaId = entry.id;
    // 企業ごとにこの駅の路線IDを持つ路線をリストアップする（全データの部分集合を作る）
    // 路線系統として含む場合もキャッチするため。
    const linesAboutCompany: typeof allStationList = {};
    Object.keys(allStationList).forEach((companyId) => {
      Object.keys(allStationList[companyId].lines).forEach((lineId) => {
        // 駅リストの方を参照し, そちらが含んでいたらリストに入れる.
        if (
          allStationList[companyId].lines[lineId].stations.find(
            (sta) => sta.slug === entry.id,
          )
        ) {
          // 事業者データが未作成なら作成
          if (!(companyId in linesAboutCompany)) {
            const { lines: _, ...rest } = allStationList[companyId];
            linesAboutCompany[companyId] = { ...rest, lines: {} };
          }
          linesAboutCompany[companyId].lines[lineId] =
            allStationList[companyId].lines[lineId];
        }
      });
    });
    interface LineAndCompany {
      line: LineDataSchema;
      company: CompanyDataSchema;
    }
    // この駅の全路線データ（JRの重複も込みで並ぶ）
    const flattenLineData = Object.values(linesAboutCompany).flatMap(
      (companyData) => {
        return Object.values(companyData.lines).map(
          (lineData) =>
            ({
              line: lineData,
              company: companyData,
            }) satisfies LineAndCompany,
        );
      },
    );
    // 路線IDごとに分けたデータ（JRの重複は配列に複数要素があることで表現）。
    const lineDataByLineId = [] as LineAndCompany[][];
    flattenLineData.forEach((data) => {
      const existingLine = lineDataByLineId.find(
        (line) => data.line.lineId === line[0].line.lineId,
      );
      if (existingLine !== undefined) {
        existingLine.push(data);
      } else {
        lineDataByLineId.push([data]);
      }
    }, [] as LineAndCompany[][]);

    // 路線ごとに隣の駅を算出する
    const siblingsStations: SiblingStationType[] = [];
    // すでに処理した路線名リスト. 重複検知に使う.
    const treatedLineNames: string[] = [];
    Object.values(linesAboutCompany).forEach((companyData) => {
      Object.values(companyData.lines).forEach((lineData) => {
        const lineName = lineData.lineName;
        // インデックスベースで隣接駅を取得する.
        const index = lineData.stations.findIndex(
          (sta) => sta.slug === entry.id,
        );
        if (index === -1) throw Error("路線の検出に誤りがあります。");
        const prev = index === 0 ? null : lineData.stations[index - 1];
        const next =
          index === lineData.stations.length - 1
            ? null
            : lineData.stations[index + 1];
        if (treatedLineNames.includes(lineName)) {
          // 処理済みとされている場合はJRの重複であるため特殊処理.
          const existing = siblingsStations.find(
            (line) => line.lineData.lineName === lineName,
          );
          if (existing === undefined)
            throw Error("隣接駅の登録に誤りがあります。");
          // prevかnextのいずれかがnullのはずである（亀山とかは考えずデータ側で除外）.
          const prevIsNull = existing.prev === null;
          if (prevIsNull && prev !== null) {
            existing.prev = prev;
          } else if (!prevIsNull && next !== null) {
            existing.next = next;
          }
        } else {
          treatedLineNames.push(lineName);
          siblingsStations.push({ companyData, lineData, prev, next });
        }
      });
    });

    return {
      params: { slug: entryStaId },
      props: { entry, lineDataByLineId, siblingsStations },
    };
  });
}

type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { entry, lineDataByLineId, siblingsStations } = Astro.props as Props;
const { name, CommentContent, updatedAt, images, firstVisitDate, noDataFlag } =
  entry;

// すべて同じ企業の駅の場合は路線名に正式なものを使う
const allLinesBelongToSameCompany =
  new Set(
    lineDataByLineId.flatMap((line) => line.map((l) => l.company.companyId)),
  ).size === 1;

// typeが駅舎のものを探す。無ければのものを使う
const thumbImage: (typeof images)[number] | null =
  images.length === 0
    ? null
    : images.find((img) => img.type.includes("駅舎")) || images[0];
const thumbnail =
  thumbImage === null
    ? null
    : await getImage({
        src: thumbImage.src,
        height: thumbImage.height,
        width: thumbImage.width,
      });

const imageOptions = [
  "駅舎",
  "駅構内",
  "駅周辺",
  "駅名標",
  "車両",
  "時刻表",
  "路線図",
  "スタンプ",
  "切符",
] satisfies StationImageTypeOptions[];

const PAGE_NAME = `Under Construction | 鉄道駅コレクション ${name}` as const;

const ogp = {
  url: Astro.request.url,
  type: "blog",
  title: PAGE_NAME,
  description: "訪問した鉄道駅をまとめたページです",
  siteName: "Under Construction",
  image:
    "https://aiwaka.github.io" +
    (thumbnail?.src ?? "/under-construction/img/blue_2.png"),
};
---

<GeneralPageLayout ogp={ogp} title={PAGE_NAME}>
  <a
    href={`${import.meta.env.BASE_URL}station-collections`}
    class="to-top-anchor">コレクショントップへ戻る</a
  >
  {/* TODO: 駅名標っぽくしたい */}
  <h1>{name}</h1>
  <div class="station-lines-block">
    <p>
      所属路線：{
        lineDataByLineId
          .flatMap((data) => {
            let resNode: any = null;
            if (data.length === 1) {
              const lineData = data[0];
              const slug = createHrefToLineSlug(
                lineData.company.companyId,
                lineData.line.lineId,
              );
              const lineName = allLinesBelongToSameCompany
                ? lineData.line.formalLineName
                : lineData.line.lineName;
              resNode = entry.lineIds.includes(lineData.line.lineId) ? (
                <a href={slug}>{lineName}</a>
              ) : (
                <>
                  (<a href={slug}>{lineName}</a>)
                </>
              );
            } else {
              const linkNodes = data.flatMap((lineData) => {
                const slug = createHrefToLineSlug(
                  lineData.company.companyId,
                  lineData.line.lineId,
                );
                return [
                  <a href={slug}>{lineData.company.companyName}</a>,
                  <>、</>,
                ];
              });
              resNode = (
                <>
                  {data[0].line.lineName}（{linkNodes.slice(0, -1)}）
                </>
              );
            }
            return [resNode, <>・</>];
          })
          .slice(0, -1)
      }
    </p>
  </div>
  <div class="date-block">
    <span>
      初訪問日：{firstVisitDate ? dateText(new Date(firstVisitDate)) : "不明"}
    </span>
  </div>
  <div class="update-date-block">
    <span>
      {dateText(new Date(updatedAt), "Asia/Tokyo")}更新
    </span>
  </div>
  {
    thumbnail !== null && (
      <div class="img-container">
        <img
          src={thumbnail.src}
          width={thumbnail.attributes.width}
          height={thumbnail.attributes.height}
          alt={thumbnail.attributes.alt}
          loading="eager"
          decoding="async"
        />
      </div>
    )
  }

  <div class="comment-container">
    <CommentContent class="comment" />
  </div>

  {
    imageOptions.map((opt) => {
      return (
        <>
          <h2>{opt}</h2>
          {noDataFlag.includes(opt) ? (
            <div style="margin: 1.5rem auto;">
              <p>この駅には該当するものがありません。</p>
            </div>
          ) : (
            <CollectionPictureList
              images={images.filter((i) => i.type.includes(opt))}
            />
          )}
        </>
      );
    })
  }

  <h2>隣の訪れた駅</h2>
  {
    siblingsStations.map((siblings) => {
      return (
        <SiblingStationOfLine
          siblings={siblings}
          useFormalName={allLinesBelongToSameCompany}
        />
      );
    })
  }

  <a
    href={`${import.meta.env.BASE_URL}station-collections`}
    class="to-top-anchor">コレクショントップへ戻る</a
  >
</GeneralPageLayout>

<style>
  .comment-container {
    margin: 1.5rem auto;
  }
  .comment-container :global(a) {
    color: darkgoldenrod;
    &:hover {
      color: orangered;
    }
  }
  a {
    text-decoration: underline;
  }
  .to-top-anchor {
    color: var(--main-font-color);
    text-decoration: underline;
  }
  .img-container {
    border: 4px solid var(--main-font-color);
    width: 100%;
    height: 22rem;
    clip: rect(0, 0, 0, 0);
    margin: 1rem auto;
  }
  .img-container > img {
    object-fit: cover;
    width: 100%;
    height: 100%;
  }
  p.comment {
    margin: 1.2rem auto;
    margin-left: 0.4rem;
  }
</style>
