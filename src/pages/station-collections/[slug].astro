---
import type { InferGetStaticPropsType } from "astro";
import { getImage } from "astro:assets";

import allStationList from "@lib/other/station-collections/data/stationList";

import type {
  DownloadedStationCollection,
  StationImageTypeOptions,
} from "@lib/schema/station";
import type {
  CompanyDataSchema,
  LineDataSchema,
  SiblingStationType,
  StationDataSchema,
} from "@lib/types";
import { dateText } from "@lib/utils";
import {
  getStationEntries,
  getDownloadedStationCollectionsData,
  type StationEntry,
} from "@lib/other/station-collections";
import { createHrefToLineSlug } from "@lib/other/station-collections";

import GeneralPageLayout from "@layouts/GeneralPageLayout.astro";
import CollectionPictureList from "@components/other/station-collections/CollectionPictureList.astro";
import SiblingStationOfLine from "@components/other/station-collections/SiblingStationOfLine.astro";

export const getStaticPaths = async () => {
  const createSiblingsData = (entry: StationEntry) => {
    // 企業ごとにこの駅の路線IDを持つ路線をリストアップする（全データの部分集合を作る）
    // 路線系統として含む場合もキャッチするため。
    const subsetStationList: typeof allStationList = {};
    Object.entries(allStationList).forEach(([companyId, companyData]) => {
      Object.entries(companyData.lines).forEach(([lineId, lineData]) => {
        // 各路線データ内の駅リストを参照し, `entry`の駅を含むなら部分集合に入れる.
        if (lineData.stations.find((sta) => sta.slug === entry.id)) {
          // 事業者のキーが未作成なら作成
          if (!(companyId in subsetStationList)) {
            const { lines: _, ...rest } = companyData;
            subsetStationList[companyId] = { ...rest, lines: {} };
          }
          subsetStationList[companyId].lines[lineId] =
            allStationList[companyId].lines[lineId];
        }
      });
    });
    const allLinesBelongToSameCompany =
      Object.keys(subsetStationList).length === 1;

    // 路線データに各駅に隣接駅情報を付与したものの列
    const siblingsData: SiblingStationType[] = [];
    Object.entries(subsetStationList).forEach(([companyId, companyData]) => {
      Object.entries(companyData.lines).forEach(([lineId, lineData]) => {
        // const lineName = lineData.lineName;
        // インデックスベースで隣接駅を取得する. すでに部分集合であるため必ず見つかるはず.
        const stations = lineData.stations;
        stations.forEach((sta, idx) => {
          if (sta.slug !== entry.id) return;
          const prev = idx === 0 ? null : stations[idx - 1];
          const next = idx === stations.length - 1 ? null : stations[idx + 1];
          const existingLine = siblingsData.find(
            (line) => line.lineId === lineId,
          );
          if (existingLine === undefined) {
            const lineName = allLinesBelongToSameCompany
              ? lineData.formalLineName
              : lineData.lineName;
            const siblingObj = {
              lineId,
              lineName,
              companies: [companyData],
              prev,
              next,
            };
            siblingsData.push(siblingObj);
          } else {
            // すでにデータがある路線に対してはマージする
            if (
              existingLine.companies.find(
                (com) => com.companyId === companyId,
              ) === undefined
            ) {
              existingLine.companies.push(companyData);
            }
            if (existingLine.prev === null) {
              existingLine.prev = prev;
            }
            if (existingLine.next === null) {
              existingLine.next = next;
            }
          }
        });
      });
    });
    return siblingsData;
  };

  /** 何らかの理由で取得に失敗した瞬間`true`になる */
  let stationCollectionsFetchFailed = false;
  let stationCollectionsData: DownloadedStationCollection | null = null;
  try {
    stationCollectionsData = getDownloadedStationCollectionsData();
  } catch (e) {
    console.error(e);
    stationCollectionsFetchFailed = true;
  }

  if (stationCollectionsFetchFailed || stationCollectionsData === null) {
    return [];
  }
  const stationEntries = await getStationEntries(stationCollectionsData);
  return stationEntries.map((entry) => {
    const siblingsData = createSiblingsData(entry);
    return {
      params: { slug: entry.id },
      props: { entry, siblingsData },
    };
  });
};

type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { entry, siblingsData } = Astro.props as Props;
const { name, CommentContent, updatedAt, images, firstVisitDate } = entry;

// typeが駅舎のものを探す。無ければのものを使う
const thumbImage: (typeof images)[number] | null =
  images.length === 0
    ? null
    : images.find((img) => img.type.includes("駅舎")) || images[0];
const thumbnail =
  thumbImage === null
    ? null
    : await getImage({
        src: thumbImage.src,
        height: thumbImage.height,
        width: thumbImage.width,
      });

const PAGE_NAME = `Under Construction | 鉄道駅コレクション ${name}` as const;

const ogp = {
  url: Astro.request.url,
  type: "blog",
  title: PAGE_NAME,
  description: "訪問した鉄道駅をまとめたページです",
  siteName: "Under Construction",
  image:
    "https://aiwaka.github.io" +
    (thumbnail?.src ?? "/under-construction/img/blue_2.png"),
};
---

<GeneralPageLayout ogp={ogp} title={PAGE_NAME}>
  <a
    href={`${import.meta.env.BASE_URL}station-collections`}
    class="to-top-anchor">コレクショントップへ戻る</a
  >
  {/* TODO: 駅名標っぽくしたい */}
  <h1>{name}</h1>
  <div class="station-lines-block">
    <p>
      所属路線：{
        siblingsData
          .flatMap((data) => {
            let resNode: any = null;
            if (data.companies.length === 1) {
              const slug = createHrefToLineSlug(
                data.companies[0].companyId,
                data.lineId,
              );
              resNode = entry.lineIds.includes(data.lineId) ? (
                <a href={slug}>{data.lineName}</a>
              ) : (
                <>
                  (<a href={slug}>{data.lineName}</a>)
                </>
              );
            } else {
              const linkNodes = data.companies.flatMap((company) => {
                const slug = createHrefToLineSlug(
                  company.companyId,
                  data.lineId,
                );
                return [<a href={slug}>{company.companyName}</a>, <>、</>];
              });
              resNode = (
                <>
                  {data.lineName}（{linkNodes.slice(0, -1)}）
                </>
              );
            }
            return [resNode, <>・</>];
          })
          .slice(0, -1)
      }
    </p>
  </div>
  <div class="date-block">
    <span>
      初訪問日：{firstVisitDate ? dateText(new Date(firstVisitDate)) : "不明"}
    </span>
  </div>
  <div class="update-date-block">
    <span>
      {dateText(new Date(updatedAt), "Asia/Tokyo")}更新
    </span>
  </div>
  {
    thumbnail !== null && (
      <div class="img-container">
        <img
          src={thumbnail.src}
          width={thumbnail.attributes.width}
          height={thumbnail.attributes.height}
          alt={thumbnail.attributes.alt}
          loading="eager"
          decoding="async"
        />
      </div>
    )
  }

  <div class="comment-container">
    <CommentContent class="comment" />
  </div>

  {
    (
      [
        "駅舎",
        "駅構内",
        "駅周辺",
        "駅名標",
        "車両",
        "時刻表",
        "路線図",
        "スタンプ",
        "切符",
      ] satisfies StationImageTypeOptions[]
    ).map((opt) => {
      return (
        images.find((i) => i.type.includes(opt)) !== undefined && (
          <>
            <h2>{opt}</h2>
            <CollectionPictureList
              images={images.filter((i) => i.type.includes(opt))}
            />
          </>
        )
      );
    })
  }

  <h2>隣の訪れた駅</h2>
  {
    siblingsData.map((siblings) => {
      return <SiblingStationOfLine siblings={siblings} />;
    })
  }

  <a
    href={`${import.meta.env.BASE_URL}station-collections`}
    class="to-top-anchor">コレクショントップへ戻る</a
  >
</GeneralPageLayout>

<style>
  .comment-container {
    margin: 1.5rem auto;
  }
  .comment-container :global(a) {
    color: darkgoldenrod;
    &:hover {
      color: orangered;
    }
  }
  a {
    text-decoration: underline;
  }
  .to-top-anchor {
    color: var(--main-font-color);
    text-decoration: underline;
  }
  .img-container {
    border: 4px solid var(--main-font-color);
    width: 100%;
    height: 22rem;
    clip: rect(0, 0, 0, 0);
    margin: 1rem auto;
  }
  .img-container > img {
    object-fit: cover;
    width: 100%;
    height: 100%;
  }
  p.comment {
    margin: 1.2rem auto;
    margin-left: 0.4rem;
  }
</style>
