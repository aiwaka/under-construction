---
import type { InferGetStaticPropsType } from "astro";
import { getImage } from "astro:assets";

import allStationList from "@lib/other/station-collections/data/stationList";

import type {
  DownloadedStationCollection,
  StationImageTypeOptions,
} from "@lib/schema/station";
import type { LineDataSchema, SiblingStationType } from "@lib/types";
import { dateText } from "@lib/utils";
import {
  getStationEntries,
  getDownloadedStationCollectionsData,
} from "@lib/other/station-collections";
import { createLineSlug } from "@lib/other/station-collections";
import { createHrefToLineSlug } from "@lib/other/station-collections";

import GeneralPageLayout from "@layouts/GeneralPageLayout.astro";
import CollectionPictureList from "@components/other/station-collections/CollectionPictureList.astro";
import SiblingStationOfLine from "@components/other/station-collections/SiblingStationOfLine.astro";

export async function getStaticPaths() {
  /** 何らかの理由で取得に失敗した瞬間`true`になる */
  let stationCollectionsFetchFailed = false;
  let stationCollectionsData: DownloadedStationCollection | null = null;
  try {
    stationCollectionsData = getDownloadedStationCollectionsData();
  } catch (e) {
    console.error(e);
    stationCollectionsFetchFailed = true;
  }

  if (stationCollectionsFetchFailed || stationCollectionsData === null) {
    return [];
  }
  const stationEntries = await getStationEntries(stationCollectionsData);
  return stationEntries.map((entry) => {
    const entryStaId = entry.id;
    // 企業ごとにこの駅の路線IDを持つ路線をリストアップする（全データの部分集合を作る）
    // 路線系統として含む場合もキャッチするため。
    const linesAboutCompany: typeof allStationList = {};
    Object.keys(allStationList).forEach((companyId) => {
      Object.keys(allStationList[companyId].lines).forEach((lineId) => {
        // 駅リストの方を参照し, そちらが含んでいたらリストに入れる.
        if (
          allStationList[companyId].lines[lineId].stations.find(
            (sta) => sta.slug === entry.id,
          )
        ) {
          // 事業者データが未作成なら作成
          if (!(companyId in linesAboutCompany)) {
            const { lines: _, ...rest } = allStationList[companyId];
            linesAboutCompany[companyId] = { ...rest, lines: {} };
          }
          linesAboutCompany[companyId].lines[lineId] =
            allStationList[companyId].lines[lineId];
        }
      });
    });
    // この駅の全路線データ（JRの重複込み）
    const flattenLineData = Object.values(linesAboutCompany).flatMap(
      (companyData) => {
        return Object.values(companyData.lines).map((lineData) => ({
          line: lineData,
          companyId: companyData.companyId,
        }));
      },
    );
    // 日本語の路線名リストを作る.
    // 厳密にその駅を含まない路線はカッコで囲む.
    const jaLineNames = flattenLineData.map((lineData) => {
      const lineName = entry.lineIds.includes(lineData.line.lineId)
        ? lineData.line.lineName
        : `(${lineData.line.lineName})`;
      return {
        slug: createHrefToLineSlug(lineData.companyId, lineData.line.lineId),
        lineName,
      };
    });

    // 路線ごとに隣の駅を算出する
    const allLinesSameCompany = Object.keys(linesAboutCompany).length === 1;
    const siblingsStations: SiblingStationType[] = [];
    // すでに処理した路線名リスト. 重複検知に使う.
    const treatedLineNames: string[] = [];
    Object.values(linesAboutCompany).forEach((companyData) => {
      Object.values(companyData.lines).forEach((lineData) => {
        // すべて同じ企業の駅の場合は正式な路線名を使う
        const lineName = allLinesSameCompany
          ? lineData.formalLineName
          : lineData.lineName;
        // インデックスベースで隣接駅を取得する.
        const index = lineData.stations.findIndex(
          (sta) => sta.slug === entry.id,
        );
        if (index === -1) throw Error("路線の検出に誤りがあります。");
        const prev = index === 0 ? null : lineData.stations[index - 1];
        const next =
          index === lineData.stations.length - 1
            ? null
            : lineData.stations[index + 1];
        if (treatedLineNames.includes(lineName)) {
          // 処理済みとされている場合はJRの重複であるため特殊処理.
          const existing = siblingsStations.find(
            (line) => line.lineData.lineName === lineName,
          );
          if (existing === undefined)
            throw Error("隣接駅の登録に誤りがあります。");
          // prevかnextのいずれかがnullのはずである（亀山とかは考えずデータ側で除外）.
          const prevIsNull = existing.prev === null;
          if (prevIsNull && prev !== null) {
            existing.prev = prev;
          } else if (!prevIsNull && next !== null) {
            existing.next = next;
          }
        } else {
          treatedLineNames.push(lineName);
          siblingsStations.push({ companyData, lineData, prev, next });
        }
      });
    });

    return {
      params: { slug: entryStaId },
      props: { entry: entry, jaLineNames, siblingsStations },
    };
  });
}

type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { entry, jaLineNames, siblingsStations } = Astro.props as Props;
const { name, CommentContent, updatedAt, images, firstVisitDate, noDataFlag } =
  entry;

// typeが駅舎のものを探す。無ければのものを使う
const thumbImage: (typeof images)[number] | null =
  images.length === 0
    ? null
    : images.find((img) => img.type.includes("駅舎")) || images[0];
const thumbnail =
  thumbImage === null
    ? null
    : await getImage({
        src: thumbImage.src,
        height: thumbImage.height,
        width: thumbImage.width,
      });

const imageOptions = [
  "駅舎",
  "駅構内",
  "駅周辺",
  "駅名標",
  "車両",
  "時刻表",
  "路線図",
  "スタンプ",
  "切符",
] satisfies StationImageTypeOptions[];

const PAGE_NAME = `Under Construction | 鉄道駅コレクション ${name}` as const;

const ogp = {
  url: Astro.request.url,
  type: "blog",
  title: PAGE_NAME,
  description: "訪問した鉄道駅をまとめたページです",
  siteName: "Under Construction",
  image:
    "https://aiwaka.github.io" +
    (thumbnail?.src ?? "/under-construction/img/blue_2.png"),
};
---

<GeneralPageLayout ogp={ogp} title={PAGE_NAME}>
  <a
    href={`${import.meta.env.BASE_URL}station-collections`}
    class="to-top-anchor">コレクショントップへ戻る</a
  >
  {/* TODO: 駅名標っぽくしたい */}
  <h1>{name}</h1>
  <div class="station-lines-block">
    {/* TODO: 南小谷とかがやばいのでなんとかする */}
    <p>
      所属路線：{
        jaLineNames.map((line, i) => {
          return (
            <>
              <a href={line.slug}>{line.lineName}</a>
              {i !== jaLineNames.length - 1 && <span>・</span>}
            </>
          );
        })
      }
    </p>
  </div>
  <div class="date-block">
    <span>
      初訪問日：{firstVisitDate ? dateText(new Date(firstVisitDate)) : "不明"}
    </span>
  </div>
  <div class="update-date-block">
    <span>
      {dateText(new Date(updatedAt), "Asia/Tokyo")}更新
    </span>
  </div>
  {
    thumbnail !== null && (
      <div class="img-container">
        <img
          src={thumbnail.src}
          width={thumbnail.attributes.width}
          height={thumbnail.attributes.height}
          alt={thumbnail.attributes.alt}
          loading="eager"
          decoding="async"
        />
      </div>
    )
  }

  <div class="comment-container">
    <CommentContent class="comment" />
  </div>

  {
    imageOptions.map((opt) => {
      return (
        <>
          <h2>{opt}</h2>
          {noDataFlag.includes(opt) ? (
            <div style="margin: 1.5rem auto;">
              <p>この駅には該当するものがありません。</p>
            </div>
          ) : (
            <CollectionPictureList
              images={images.filter((i) => i.type.includes(opt))}
            />
          )}
        </>
      );
    })
  }

  <h2>隣の訪れた駅</h2>
  {
    siblingsStations.map((siblings) => {
      return <SiblingStationOfLine siblings={siblings} />;
    })
  }

  <a
    href={`${import.meta.env.BASE_URL}station-collections`}
    class="to-top-anchor">コレクショントップへ戻る</a
  >
</GeneralPageLayout>

<style>
  .comment-container {
    margin: 1.5rem auto;
  }
  .comment-container :global(a) {
    color: darkgoldenrod;
    &:hover {
      color: orangered;
    }
  }
  .to-top-anchor {
    color: var(--main-font-color);
    text-decoration: underline;
  }
  .img-container {
    border: 4px solid var(--main-font-color);
    width: 100%;
    height: 22rem;
    clip: rect(0, 0, 0, 0);
    margin: 1rem auto;
  }
  .img-container > img {
    object-fit: cover;
    width: 100%;
    height: 100%;
  }
  p.comment {
    margin: 1.2rem auto;
    margin-left: 0.4rem;
  }
</style>
