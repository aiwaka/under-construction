---
import type { InferGetStaticPropsType } from "astro";
import { getCollection, getEntryBySlug } from "astro:content";
import { getImage } from "@astrojs/image";

import type {
  FinalBlogCollectionEntry,
  FrontmatterByRemarkPlugin,
} from "@lib/schema";
import { dateText, getBlogPostEntries } from "@lib/utils";

import BlogGeneralLayout from "@layouts/BlogGeneralLayout.astro";
import SiblingsLinkContainer from "@components/blog/SiblingsLinkContainer.astro";
import TagContainer from "@components/blog/TagContainer.svelte";
import ArticleTag from "@components/blog/ArticleTag.svelte";

interface RelatedEntry {
  slug: string;
  title: string;
  /** 関連に入れられる基準となったタグ, または'specified' */
  whyRelated: string;
}

export async function getStaticPaths() {
  const allBlogPosts = await getCollection("blog");
  const blogPostEntries = await getBlogPostEntries(allBlogPosts);
  blogPostEntries.sort((a, b) => (a.data.date < b.data.date ? 1 : -1));

  // TODO: 静的ビルドなのでパフォーマンスに影響はないが, だいぶ冗長なのでコードを見直す
  return await Promise.all(
    blogPostEntries.map(async (entry, i, array) => {
      const next = i === 0 ? null : array.at(i - 1) ?? null;
      const prev = i === array.length ? null : array.at(i + 1) ?? null;
      // 以下で関連記事を追加する.
      // 記事のタグごとにリスト化し, タグごとに一つずつ関連記事として取る.
      const relatedSlugList: { slug: string; why: string }[] = [];
      entry.data.related.forEach((related) =>
        relatedSlugList.push({ slug: related, why: "specified" })
      );
      const tags = [...entry.data.tags];
      // タグに対してフィルターした記事情報を保存するオブジェクト
      const filteredDict: { [K: string]: FinalBlogCollectionEntry[] } = {};
      tags.forEach((tag) => (filteredDict[tag] = []));
      // 一度全部のエントリーを見て, タグに重複があるものを辞書オブジェクトに追加する
      for (const tempEntry of array) {
        if (
          tempEntry.slug === entry.slug ||
          relatedSlugList.map((obj) => obj.slug).includes(tempEntry.slug)
        ) {
          continue;
        }
        for (let tempTag of tempEntry.data.tags) {
          if (tags.includes(tempTag)) {
            // spliceで最初に追加することで後でpopで取り出したときの時間順を適切にする
            filteredDict[tempTag].splice(0, 0, tempEntry);
            break;
          }
        }
      }
      // 5個程度になるまで関連記事を追加する.
      while (relatedSlugList.length <= 5) {
        let addedNum = 0;
        // タグを順番に見て一つずつ追加
        for (const tag of tags) {
          const popped = filteredDict[tag].pop();
          if (popped) {
            relatedSlugList.push({ slug: popped.slug, why: tag });
            addedNum += 1;
          }
        }
        // 追加されることがないなら足りなくても終了
        if (addedNum === 0) break;
      }
      // 得たslugのリストからエントリーを得て必要な形の配列に変換
      const related = await Promise.all(
        relatedSlugList.slice(0, 5).map(async ({ slug, why }) => {
          const entry = await getEntryBySlug("blog", slug);
          if (entry === undefined) {
            throw new Error(`slug '${slug}' is not defined`);
          }
          return {
            slug: entry.slug,
            title: entry.data.title,
            whyRelated: why,
          } satisfies RelatedEntry;
        })
      );
      return {
        params: { slug: entry.slug },
        props: { entry, next, prev, related },
      };
    })
  );
}

type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { entry, next, prev, related } = Astro.props;
const { Content, remarkPluginFrontmatter } = await entry.render();
const {
  title,
  description,
  date,
  updateDate,
  thumbnail,
  thumbnailFormat,
  tags,
  latex,
} = entry.data;
const additionalFrontmatter =
  remarkPluginFrontmatter as FrontmatterByRemarkPlugin;
const wordCount = additionalFrontmatter.wordCount;

const img = await getImage({
  src: import(`../blog/thumb/${thumbnail}.${thumbnailFormat}`),
  format: "webp",
  width: 1024,
  alt: "thumbnail",
});
const ogp = {
  url: Astro.request.url,
  type: "blog",
  title: `Under Construction | blog | ${title}`,
  description,
  siteName: "Under Construction",
  image:
    "https://littleikawa.github.io" +
    (img.src ?? "/under-construction/img/blue_2.png"),
};
---

<BlogGeneralLayout ogp={ogp} title={title} usingLatex={latex}>
  <h1>{title}</h1>
  <div class="date-block">
    <span>
      {dateText(date)}
      {updateDate ? <>（{dateText(updateDate)} 追記）</> : null}
    </span>
  </div>

  <TagContainer tagList={tags} />
  {
    /* NOTE: この文字数カウントが正確か検証はしていない. 大体あっていそうだが... */
  }
  <div class="word-count">
    <span>文字数：{wordCount}</span>
  </div>
  <div class="img-container">
    <img
      src={img.src}
      width={img.width}
      height={img.height}
      alt={img.alt}
      loading="eager"
      decoding="async"
    />
  </div>
  <div class="blog-article-content-container">
    <Content />
  </div>
  <SiblingsLinkContainer next={next} prev={prev} />
  <h2>関連記事</h2>
  <div class="related-articles-container">
    {
      related.map(({ slug, title, whyRelated: why }) => {
        return (
          <a
            class="article-link"
            href={`${import.meta.env.BASE_URL}blog/${slug}`}
          >
            <div class="related-article">
              <span>{title}</span>
              {why !== "specified" && <ArticleTag tag={why} />}
            </div>
          </a>
        );
      })
    }
  </div>
</BlogGeneralLayout>

<style>
  .img-container {
    border: 4px solid var(--main-color);
    width: 100%;
    height: 45vh;
    clip: rect(0, 0, 0, 0);
    margin: 3rem auto;
  }
  .img-container > img {
    object-fit: cover;
    width: 100%;
    height: 100%;
  }
  :global(.blog-article-content-container) {
    line-height: 1.8rem;
  }
  .blog-article-content-container :global(a) {
    color: darkgoldenrod;
    &:hover {
      color: orangered;
    }
  }
  .blog-article-content-container :global(h2) {
    margin-top: 4rem;
    margin-bottom: 1.4rem;
  }
  .blog-article-content-container :global(h3) {
    margin-top: 2.5rem;
  }
  .blog-article-content-container :global(p) {
    margin: 1.5rem 1rem;
    @media (max-width: 1024px) {
      margin: 1.5rem 0;
    }
  }
  .blog-article-content-container :global(img) {
    width: 100%;
    height: auto;
  }
  .blog-article-content-container :global(ul) {
    margin: auto 1rem;
    padding-left: 1.6rem;
  }
  .blog-article-content-container :global(blockquote) {
    margin: 0 1rem;
    /* paddingの縦が0だとpタグのmarginと相殺されるため微小量を設定する */
    padding: 1px 0.8rem;
    background-color: rgba(var(--main-color-params), 0.2);
    border-radius: 10px;
  }
  .blog-article-content-container :global(nav.toc) {
    & :global(.toc-link) {
      color: var(--main-color);
      &:hover {
        color: orangered;
      }
    }
    padding: 0.8rem 1.2rem;
    background-color: rgba(200, 200, 200, 0.5);
    border-radius: 5px;
    & :global(ol) {
      margin-left: 1.6rem;
    }
  }
  /* h2, h3見出し開始位置を崩さない処理と, 見出し上でホバーしたらアンカーリンク（#文字）が表示される処理. */
  .blog-article-content-container {
    & :global(span.anchor-link) {
      display: inline-block;
      width: 1rem;
      margin-left: -1rem;
      color: transparent;
    }
    & :global(h2:hover span.anchor-link) {
      color: inherit;
    }
    & :global(h3:hover span.anchor-link) {
      color: inherit;
    }
  }
  /* 脚注の下の<p>タグの行間を詰める処理 NOTE: むしろrehypeで<p>タグを取ってもいいかもしれない. */
  .blog-article-content-container {
    & :global(h2#footnote-label + ol) {
      margin: 1.7rem 1rem;
      & :global(p) {
        margin-top: 0;
        margin-bottom: 0;
      }
    }
  }

  .related-articles-container {
    display: flex;
    flex-direction: column;
    margin: 1rem 0;
    & .article-link {
      border: 1px solid var(--main-color);
      border-bottom: 0;
      background-color: rgba(var(--main-bg-params), 0.6);
      &:last-child {
        border: 1px solid var(--main-color);
      }
    }
    & .article-link:hover {
      background-color: var(--main-color);
      color: var(--main-bg-color);
    }
    & .related-article {
      padding: 1.1rem 1rem;
    }
  }
</style>
