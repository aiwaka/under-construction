---
title: Rust製ゲームエンジンBevy (v0.9) で音ゲーをつくる [vol.2]
description: "Rustで音ゲーをつくる連載"
thumbnail: bevy-rhythm-game.png
date: 2022-12-04
tags:
  - プログラミング
  - ゲーム
  - Rust
  - Bevy
---

<script>
  import { base } from "$app/paths";
</script>

## はじめに

第二回です.
前回は[こちら](https://littleikawa.github.io/under-construction/blog/20221204-bevy-rhythm-game-vol1/).

今回は譜面データを構成する手法を紹介します.
最初の最初に断っておきますが, 構成手法が正しいかどうか全然わからないです.
とりあえず私がこの方法で実装したということについて述べていることをご承知ください.

以前に今回はローディングと言っていましたが, 先に譜面データを構成する手法を紹介します.

## モジュール構造について

譜面のデータ構造の前に, ファイルをどのように分けるかについて説明しておきます.
最終的なディレクトリ構造は以下のようになります.

```shell
simple_rhythm_game
├── Cargo.lock
├── Cargo.toml
├── assets
│   ├── fonts
│   │   └── FiraSans-Bold.ttf
│   └── songs
│       ├── song1.wav
│       └── song1.yaml
└── src
    ├── components
    │   ├── mod.rs
    │   └── ...
    ├── constants.rs
    ├── events.rs
    ├── main.rs
    ├── resources
    │   ├── mod.rs
    │   └── ...
    └── systems
        ├── mod.rs
        └── ...
```

`assets`はBevyのデフォルトのアセット保存ディレクトリ名で, そのまま使っています.
`songs`以下はBevyにおける狭義のアセットとしては使いませんがここに置いています.
`src`以下を見ますと, `main.rs`のほか, 第一回で作った`constants.rs`, イベントの定義や追加を行う`event.rs`があります.
Bevyの特徴的な要素であるECSを司るのが`components`, `resources`, `systems`モジュールです.
ここに役割ごとにソースコードを置いていくことで管理します.

ただ, `resources`で定義した構造体に`Component`を付与することもあり`components`と`resources`を分ける理由がやや曖昧になっているなど, 改善の余地が大いにあると思います.

なお, `mod.rs`を使わずにモジュールをディレクトリ分割できますが, 個人的にこの方法が好きというだけです.

## 譜面データの構造について考える

### 基本的な要素

音ゲーの譜面を管理する上で必要な要素は何でしょうか.
少なくとも曲名と曲ファイル名は必要です（サムネイル画像ファイル名とかもあるといいかもですが今回は省きます）.
そしてノーツ情報が最も本質的で, これをどう表現するかが問題かと思います.

ノーツは音符です.
音符のWikipediaには以下のように書いてあります.

> 音符は五線譜などの中で、相対的な音の長さ（音価）と時間的な位置、および高さ（音高）を表す。

この中で最も一般的と言えるのは時間的な位置です.
多くのゲームには鍵盤にあたるシステムがあり, 音高を表現していますが, 例えばCHUNITHMの全幅ノートに音高と呼べる要素はありません.
また音の長さも, タップノートに長さを設定するのはナンセンスであり, ホールドのような要素と共通化するのは難しいです（`Option`型を使う手はありますが, 外部データファイルで記述するのでパースを難しくしたくないという問題があります）.

一方, 判定に到達する時間は音ゲーの一連のプレイの中でどのようなノートにも絶対に存在するものです.
したがって, これをベースに, ノートの種類ごとに持つべき情報を拡張する仕組みを考えます.

なお, 到達時間を基盤にすると便利なことがあり, 拍子やBPMの変更も見えず取れないノートとして実装するだけでよくなります.
したがって, 曲の最初の時点での拍子やBPMを情報としてもたせれば十分になります（最初にそのノーツを入れるという制約付きで構成するのもいいかもしれません）.

時間位置を表現する場合, 直感的なのは小節番号と拍番号を使うことです.
これらが定まっていれば, 拍子の変化情報があれば相対位置は決まり, BPMの情報もあれば時間的な絶対位置が定まります.
またノーツの移動速度があれば, 出現時間も決まります.

なお, ゲームによってはプレイ中に譜面速度を変更できますが, 今回は簡単にするためにこの機能は前提としないことにします.
（到達時間は変化しないので, プレイ中にノーツの絶対位置を計算するなどすれば実現できると思います.）

### Rustで使える構造を用いた表現

実装するのはRustでパースするのはserdeなので, これらが扱いやすい構造を使うことを考えます.
簡単に言うと, 構造体付きの列挙型, 基本的な数値型, String型, 以上のみを含む構造体のみを扱うようにします.

構造体付き列挙型をどう表現するかが問題になりますが, ここをうまくやってくれるためにYAMLを選択しました.
YAMLにはカスタムタグを使うことができます（AWSの定義ファイルとかで見ることがあるらしいです）.
`!tag`のように, `!`をつけて記述します.

Rustで以下のような構造体を`serde`でパースすると, 次のようになります.

```rust:Rust
vec![
    Parser {
        bar: 0,
        beat: 0.0,
        note: NoteTypeParser::Normal { key: 0 },
    },
    Parser {
        bar: 0,
        beat: 0.5,
        note: NoteTypeParser::Normal { key: 1 },
    },
]
```

```yaml:YAML
- note: !Normal
    key: 0
  bar: 0
  beat: 0.0
- note: !Normal
    key: 1
  bar: 0
  beat: 0.5
```

列挙型の列挙子がタグとして付与され, 指定すべきフィールドがわかるようになっています.
このように, `bar`（小節番号）と`beat`（拍）をベースに, 好きな構造を追加で付与することができます.
ところでYAMLはインライン形式でも書けるので, 上のパース結果を次のように変更しても同じ意味です.

```yaml:YAML
- { bar: 0, beat: 0.0, note: !Normal { key: 0 } }
- { bar: 0, beat: 0.5, note: !Normal { key: 1 } }
```

こうするとぱっと見てわかりやすくなります.
本来は譜面制作ユーティリティを用意してやるべきなので見た目については関係ないのですが, 今回私は面倒だったので全部手で譜面データを書きました.
そのため, 見た目にすっきりしていることも重視しました.
そうでなくとも自分で定義した名前を使ってカスタム属性を付与できるのは嬉しいところです.

なお, `redhat.vscode-yaml`拡張機能等でYAMLのサポートを得る場合, カスタムタグを使うには追加の設定が必要です.
リポジトリに含めてありますが, ワークスペースの設定として

```json:settings.json
{
  "yaml.customTags": [
    "!Normal mapping"
  ],
}
```

等が必要です.

### 外部データとゲーム内データの受け渡し

ここまでで必要な要素をどのように記述するか決めました.
`serde`はderiveマクロが非常に強力なため, 適当な構造体に`derive(Deserialize, Serialize)`をつけるだけでほぼ問題なくデータ文字列を構造体に変換してくれます（読み込むだけなら`Serialize`は必要ないですが, 後のことも考えてとりあえずつけておきます）.

ただ, 読み込んだデータファイルをそのままゲーム内で使うには不都合があることが多いです.
例えばゲーム内で扱うノーツ情報には曲開始から到達するまでの現実の時間を含めたいですが, データファイルにこの情報をいれることはできません.
また, ゲーム内でのノーツの種類のフィールド名は`note_type`としたいですが, データファイル上の名前としては長すぎるため`note`としたいです.

このため, 文字列をパースするための構造体と, 実際に扱う構造体を2つ用意するのが定石のようです.
Rustには`From`トレイトがあり, このような変換に意味をもたせることが簡単にできます.
`From`を使えば`Into`も実装されるため, 様々な場面で扱いやすくなります.

パース用構造体に`Deserialize`を実装し, 対応する構造体に`From`を実装することで, 帰納的に変換を行うことができます.

## 構造体をつくる

以上を踏まえて実際に構造体を用意してみます.

## Vol.2 まとめ

とりあえず導入を書きました.
次回はローディングとかについて書きたいと思います.

ここまで読んでいただいた方には感謝を申し上げるとともにお気づきのことかと察しますが, 私は文章をまとめるのが非常に下手な人間です.
コードは多く載せるようにしていくので雑にご覧くだされば幸いです.
